---
layout: post
title:  "You Can't \"Know\" A Programming Language"
date:   2023-03-11
categories: jekyll update
---

I see a lot of job postings that, if they aren't putting a programming language directly in the
title of a position they are hiring for, will put the name of the language as an important
requirement somewhere in the job description. I believe this is a practice guided by a misconstrued
perception of what the relationship is between people and their software development ability. There
should be no "Java Developer"--there should be only "Software Developer," regardless of the
languages a person will be interacting with in a job.

Languages are not separate enough from one another in a sense that warrants different job
occupations for each one. If a technical divide must be drawn between different programming
intensive jobs, it should be at a higher level, defined perhaps by the distance from the silicon
with which a person is working. That is, these should be low-level systems development, computer
network development, work with data in scripts, etc. Even with these broader categories, it is
difficult to see why one would believe that the people capable of performing well in one role
wouldn't be able to perform well in the other, given that the problems requiring an experienced,
human mind in one role are almost always the exact same problems arising in the others. These
include the complexity of algorithms used, that is, if they are not taken straight from a library.
Other are the issues that arise when programming concurrent processes, and the problems that come
with systems that are developed by large groups of people simultaneously, such as version control.
This characteristic of programming work, that it does not vary much between mutually exclusive
categories within it, no matter how you define them, is heavy at the low level of separation that
are programming languages.

The most common response to this argument I see is that, regardless of the conceptual similarity
that exists between problems in different languages, grokking the intricacies of a language, or even
a framework within a language (e.g., React), is time consuming, at the expense of the organization
that is hiring the individual. They would much rather hire a programmer who happened to have worked
with Kotlin for a project at their previous job than hire what may be a more competent programmer
who has never bothered to touch the language. This line of thinking is unfair not only to the
programmer but to the organization that seeks to employ someone. The time that is spent reading and
getting comfortable with what is different about a language to what the programmer is familiar with
is, over the length of that person's employment, outweighed by their ability to problem solve in the
long term. As such, their value to the company is much higher in the long term, and this period of
time is not long, I would estimate at most a year.

It is not difficult to understand why this view is so prevalent. Human ability to problem solve in
software does not specialize to the extent that it does in many occupations that deal with the
physical world. The trades, for example, may become so specialized as to deal with separate
household appliances or components within a single home electrical system. Physicians will spend
years focusing one particular organ within the human body. The reason for this is that these roles
are more descriptive in their problem solving than they are constructive. A physician's most
valuable ability is their intricate knowledge of the human body as is knowledge of the workings of
cars to the auto mechanic. The problems they face can be dealt with directly with this knowledge,
and their ability to solve them scales directly with the amount of knowledge they have on the
domain. This scaling does not exist in the realm of software.

The development of software does not benefit from the familiarity one has with the language they are
working with, because the language is a tool, not the thing they are grappling with. The programmer
is grappling with something much larger, which is the natural limits of what information is
attainable in a limited amount of time and how it must be directed to achieve a certain outcome.
This is not something with a structure that can be memorized and recited when confronted with a
problem.

Not all occupations that deal with the physical world have this same characteristic, of scaling in
solvability in relation to the knowledge of physical object that one has. Architects and other
artists can know everything there is to know about their construction materials, environments, and
canvases, without getting better at what they do. That is because the problems they are faced with
are also constructive as opposed to descriptive. That is, in order to achieve the goal they want to
accomplish, they cannot refer to the inner workings of what they are working with, but rather with
the natural constraints set in place by the universe. They will move forward in their obstacle not
by understanding the object within which the problem lies but rather by understanding the domain
within which one can act. In software, and in all fields with constructive as opposed to descriptive
problems, this domain is limitless. It is nature itself, and in particular, in software it is
mathematical as opposed to physical.

This line of thinking is held in most frequency by people who do not know much about the technical
aspects of software development, and who also happen to be those most likely to be doing the hiring
in many organizations, especially outside of Big Tech. It would benefit everyone, I think, to 
be more aware of this distinction in software from other types of jobs.